# C++14: auto, lambda, tuple

+ Задачи
    + ~~ДЗ~~
        + ~~Добавить тестирование и пуш в гитхаб (использовать 1)~~
    + Посмотреть на начинку FTXUI - насколько она соответствует понятиям функторов
        + На удивление, не очень похоже, чтобы оно было основано на функторах
    + ~~Use submodule for GTest (DZ 1)~~
        + `add_subdirectory(googletest EXCLUDE_FROM_ALL)`
        + Проверить, что мой вариант сборки не содержит файлы сборки gtest
            + : Кажется, мой способ добавил googletest, размер последних пакетов сильно вырос относительно старых вариантов
            + Чем проверять
                `dpkg -c packet`
            + Установить проверку включения
                + Использовать тестовую установку пакета в тестовом контейнере (как следать?)
        + Попробовать открыть RPM и DEB пакеты архиваторами (разными) - tar, 7zip, unzip
















+ `.gitignore`
    + его не всегда правильно коммитить в репозиторий
        + альтернативы (действуют локально и не сохраняются в репозиторий в github)
            + внести `.gitignore` в `.gitignore`
            + `.git/info.exclude` файл


+ `__PRETTY_FUCTION__` 
    + Макросс для получения сигнатуры функции в текстовом виде для вывода в консоль
    + Дополнительно может быть использован в шаблонных функциях для получения информации о раскрытии шаблонов


+ Дополнительыне премудрости
    + GCC/Clang перестанут ругаться на неиспользованные переменные, если в конце выполнения привести эти переменные к `void`
    + Фактическая замена `[[maybe_unused]]`
+ Отличия `using` и `typedef`
    + `using` может быть шаблонным, т.к. он полностью принадлежит C++, `typedef` - менее способное наследие C

+ Логика формирования типов в шаблонах и `auto`
    + Константность (наличие `const`) не бегает вместе с типом
        + Это логично, т.к. мы постоянно создаем новые объекты памяти с помощью копирования. Копирование не будет переносить константность, константность нового объекта нужно определять отдельно
    + Ссылочность (наличие &) не бегает вместе с типом
        + Что значит отрезание ссылочности
            + Имеющееся значение у объекта, на которого была сделана ссылка, копируется
    + `volatile` также отрезается
        + Свойство запрещает использование оптимизаций. Скомилированный код должен прямым образом сходить к памяти, компилятор не имеет права применять какие-либо оптимизации с этой переменной
        + В embedded индустрии это свойство позволяет не изменять память самовольно (эту память может использовать какой-то другой программный модуль, и выполняющаяся программа не имеет права менять его)
    
    
    
    + Указатель не отрезается от типа - он является формирующей частью типа, `int` отличается от `int*`    
        + Теперь вопрос с использованием `const` у указателей.
            + `const char *`
                + нельзя менять память (запоминать по тому, что литералы применяются именно как этот тип)
                + `auto` не отбросит эту константность
            + `char * const`
                + нельзя изменять сам указатель
                + `auto` отбросит эту константность



+ Другие способы выведения типа 
    + `decltype()`
        + задача эквивалента `auto`, но использует выражения для выведения типов вместо инициализатора
        + правила другие
            + ничего не отбрасывает, использует как есть
        + Зачем нужно
            + Магия использования внутри шаблонов - явное выведение типов через `decltype`, если компилятор не способен сам определить нужное значение
            + Разыменовывание указателя на значение определяется `decltype` как `type&`
            + Использование скобочек при выведении типа позволяет произвести подстановку выражения - также добавляется ссылка `&`
                
    + `decltype(auto)`
        + обычный деклтайп, но использует инициализатор для определения типа. Синтаксис становится похож на поведение обычного `auto`
            + Только правила управления приведением используются от `decltype`



+ Лямбды
    + Функтор
        + Мы можем попросить объект использовать рядом с собой `()` как это делают обычные функции. 
            + Для этого нужно перегружать оператор `operator()` в опеделении класса
            + Затем в этот объект можно будет передавать параметры как в функции, и исполнять код, выписанный внутри классов
        + В чем крутость
            + Использование состояний фукнций и замыканий (переход к лямбдам)
    + Лямбды являются формами функтуров (синтаксический сахар)
        + Очень сильное напоминание тут про FTXUI. На самом деле все кложуры, которые там используются, являются функторами в понимании C++ (ПОСМОТРЕТЬ ФАКТИЧЕСКУЮ РЕАЛИЗАЦИЮ ПОВЕДЕНИЯ FTXUI)
            + Критика: с высокой вероятностью механика, используемая в FTXUI - использование объектов-функторов. 
        + Другие форматы использования
            + Цикл `std::forezch`



+ Кортежи
    + Проблема возвращения нескольких значений
        + `in`-`out` (хрень из сей)
        + свой собственный класс (датакласс)
        + `std::typle`
            + Крутости
                + C++17 - распаковка кортежей (`auto [id, name] = tuple`)
                + Ранее - `std::tie()`




# Homework 1

```c++
// Какой тип будет у аргументов param в каждом из следующих вариантов вызова шаблонных функций?

template <typename T>
void func1(T param) {
// some very interesting code
}
template <typename T>
void func2(T& param) {
// some very interesting code
}
template <typename T>
void func3(T* param) {
// some very interesting code
}
template <typename T>
void func4(T&& param) {
// some very interesting code
}
int main(int argc, char * argv[]) {
    int i = 10;
    const int ci = 15;
    const int &cir = ci;
    int * pi = &i;
    const int * cpi = &i;

    func1(i); // 1.1. param type ?  int
    func1(ci); // 1.2. param type ?  int
    func1(cir); // 1.3. param type ? int
    func1(42); // 1.4. param type ? int
    func1(pi); // 1.5. param type ? int*
    func1(cpi); // 1.6. param type ? const int*
    func1({1}); // 1.7. param type ? int
    func1({1, 2, 3}); // 1.8. param type ? //не компилириуется
    func2(i); // 2.1. param type ? int& 
    func2(ci); // 2.2. param type ? int&
    func2(cir); // 2.3. param type ? int&
    func2(42); // 2.4. param type ? //не компилируется
    func2(pi); // 2.5. param type ? int*&
    func2(cpi); // 2.6. param type ? const int*&
    func3(i); // 3.1. param type ? //не компилируется
    func3(ci); // 3.2. param type ? //не компилируется
    func3(cir); // 3.3. param type ? //не компилируется
    func3(42); // 3.4. param type ? //не компилируется
    func3(pi); // 3.5. param type ? int*
    func3(cpi); // 3.6. param type ? const int*
    func4(i); // 4.1. param type ? int&&
    func4(ci); // 4.2. param type ? int&&
    func4(cir); // 4.3. param type ? int&&
    func4(42); // 4.4. param type ? int&&
    func4(pi); // 4.5. param type ? int*&
    func4(cpi); // 4.6. param type ? const int*&
    return 0;
}
```






# Homework2
//работа с auto - откинута т.к. одно и то же, что и типы выше
//работа с tuple - откинута за ненужностью


# Homework3 
выполнена