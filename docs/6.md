# Аллокаторы

+ Задачи
    + ДЗ
        + Посмотреть 7 сначала чтобы понять как работает rebind
        + Реализовать аллокатор с возможностью резервирования
            + reserve не получится вызывать у стандартных контейнеров, т.к. функция `reserve` этого аллокатора не входит в интерфейс аллокаторов
                + потребуется реализовать резервирование в процессе первой аллокации памяти
        + Использовать аллокатор с в стандартном контейнере
        + Реализовать свой контейнер, который использует функционал кастомного аллокатора
            + Основная задача посмотреть на использование аллокатора
            + Но можно попробовать поэкспериментировать с контейнером, попробовать создать собственный `custom map` или `custom set` на деревьях или хеш-таблицах 
        + Порешать задачи на Timus Online Judge
            + Посмотреть задачки?
    + Что такое NUMA node и как это поймать в компе
    + Как написать собственный сборщик в C++ (делать после ДЗ)
    + Что за чудище `std::free()`? Может, есть и `std::malloc()`??? (есть, КТО ОНИ ТАКИЕ????)


+ 5 работа
    + Ну, там были умные указатели, работу с ними и реализацию кастомных версий я упустил, т.к. этот момент уже объяснен в других видео



+ Аллокаторы
    + Где хранится объект?
        + Указатели отвечают на вопрос "как долго хранить некоторый объект"
        + Коллекции отвечают на вопрос "в каком логическом порядке хранить объекты"
        + Аллокаторы отвечают на вопрос "в каком месте памяти хранить объекты"
        + Нафига вообще нужно знать, где хранится объект?
            + Далеко не всегда это важно в C++
            + Дополнительные вещи решаются с помощью системных вызовов и ручного управления памятью
            + Аллокаторы - лишь вариант решения вопроса
    + Разговор об аллокаторах идет в терминах коллекций (*и по идее, умных поинтеров, этот вопрос проверить*)
    ```c++
        std::vector<int, MyAllocator<int>>
    ```
    + Используют шаблонный полиморфизм
        + Описание неявного интерфейса (фактически доступно, если взглянуть на описание самого `std::allocator`)
            + Какие действительно потребуется реализовать (остальное компилятор сам возьмет как type traits)
                + `using value_type = T`
                    + Alias типа, с которым работает аллокатор 
                + `T* allocate(std::size_t n)`
                    + n воспринимается как количество аллоцируемых объектов
                + `void deallocate(T* p, std::size_t n)`
                + ```C++
                    template<typename U, typename ...Args>
                    void construct(U* p, Args&&... args)
                    {
                        new(p) U(std::forward<Args>(args)...);
                    }
                  ```
                    + Или как запустить конструктор объекта на памяти через placement new
                + `void destroy(T* p)`
                + `template <typename U> struct rebind { using other = logging_allocator<U>}`
                    + Нужно для усложнений при вычислении типов в компайл-тайме
                        + Причина - нужно каким-то образом вытягивать внутренние типы контейнеров вроде TreeNode или чего-то такого
                            + other хранит заложенную TreeNode (или что-то другое) как тип


+ Типы управления памятью
    + Управление чистой кучей системными вызовами
        ```c++
            {
                void* p = malloc(sizeof(MyClass));
                MyClass* ptr = new (p) MyClass(42);

                //..

                ptr->~MyClass();
                free(p);   //память, созданная malloc(), должна быть удалена с использованием free(), delete ptr тут нельзя использовать
            }
        ```
    + Счетчики ссылок
        + Дефолтные умные указатели занимаются тем же самым чистым управлением кучей, однако внутри себя содержат систему подсчетов, которая и позволяет управлять временем жизни объектов
    + Сборщики мусора


+ Как повлиять на выделение памяти? По большей части вопрос реализуем для контейнеров *и для умных указателей*
    + Переопределить malloc() и free()
        + Произойдет везде
        + Позволит использовать другой тип памяти или назначить дополнительные действия
            + Именно так работают memory leaker - подменяют malloc() и добавляют туда отслеживание трат памяти
    + Переопределить операторы new/delete
        + Определяем кастомные операторы new для отдельных классов, чтобы не затрагивать поведение всего бинаря
    + Создать кастомные аллокаторы


+ Проблема фрагментации памяти
    + Если выделять куски памяти разного размера, память постепенно будет фрагментироваться до того момента, как в ней не получится разместить достаточно большие объекты из-за отсутствия окон памяти подходящего размера
        + Решение - сделать каскад аллокаторов, для которых будет выделен кусок памяти, и который будет делиться между блоками памяти определенного одинакового размера под каждый объект
            + И затем использовать подходящие по размерам аллокаторы для разных по размерам объектов
    + Рантайм языка C++ уже по умолчанию использует разные аллокаторы для выделения разных размеров памяти
        + Благодаря этому не происходит бесконечное расширение адресного пространства памяти программы 



+ Статический полиморфизм C++
    + Классический полиморфизм
        + Есть базовый класс с набором виртуальных функций и хотя бы одной "полезной" функцией
        + Есть класс, который наследуется от базового класса и реализует "полезную" функцию внутри себя
        + Дальнейшее использование ссылки на базовый класс (`IObject&`) позволяет затем изменять поведение закрепленного кода в зависимости от реализации виртуальной функции внутри наследующего класса
            + Реализация принципа открытости-закрытости
    + Полиморфизм на шаблонах
        + ```C++
            template<typename SomeType>
            void template_poly(SomeType& obj)
            {
                obj.doSomething();
            }
          ```
        + Обеспечивает использование разных классов, даже не связанных веткой наследования
            + Однако они должны обладать определенным поведением
            + То есть, есть требование к соблюдению неявного интерфейса




+ Как работают traits
    + Каким образом компилятор может собрать тип, если не все члены класса объявлены пользователем?
        + В процессе ининциализации аллокатора вообще можно инициализировать минимум функций
            + конструктор, конструктор копирования (пустой), `allocate` и `deallocate`
        + Все остальное будет вытянуто компилятором самостоятельно
    + Добавили `std::allocator_traits`
        + На самом деле стандартные контейнеры используют `std::allocator_traits<custom_allocator>`
            + И уже эта дополнительная структура описывает недостающие внутри кастомного аллокатора методы и структуры
                + Объяснение, как это работает - шаблонная магия (возможно в 7)


+ Дебаггинг
    + MSVC добавляет специальную структуру `std::Container_proxy_`, которая используется дебаггеом Visual Studio для обработки опасных ситуаций с контейнерами


+ Полиморфные аллокаторы
    + С точки зрения компилятора контейнеры с кастомным аллокатором и системным - разные типы   
        + Полностью разные для функций
        + С ними обоими нельзя выполнять операции перекидывания значений
    + C++17 добавляет `std::pmr` и начинку, которая реализует поведение кастомных аллокаторов для статического полиморфизма на наследовании
        + Сами кастомные аллокаторы (`std::pmr::memory_resource`)
        + Контейнеры, которые будут использовать полиморфизм для управления аллокаторами
        + Проблемы
            + `std::pmr::vector` != `std::vector` 