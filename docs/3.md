# C++14: move semantic, variadic, POD


+ Задачи
    + Посмотреть [CppCoreGuidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
    + ~~SSO (почитать поподробнее)~~
        + Размер SSO зависит от платформы и реализации компилятора
    + ~~`std::copy()` и `std::swap()` - сколько они тратят памяти и времени, и что они такое~~
        + swap - чаще всего выполняет `std::move()` с использованием временной переменной
        + copy - просто вызывает констуркторы копирования объектов для копирования памяти из одной точки в другую
        + Дополнительные функции (кроме того, что уже описано в самой статье)
            + `std::move_if_noexcept()` - безопасный вариант

    + ~~что такое placement new?~~
        + синтаксис `new (адрес) Тип(аргументы)`
        + Техника позволяет конструировать объекты в заранее выделенной памяти
            + Память выделяется нестандартным образом
            + Память выделена с помощью системных вызовов
            + Сам `new` не выделяет память, а только использует переданных ему адрес памяти
        
    + ~~как вообще эти rvalue ссылки реализованы внутри c++?~~
        + Под капотом обычные ссылки-указатели, но с дополнительной информацией о том, что объект является временным 

    + ~~объяснение определения `std::move`~~
        ```c++
            template <typename T>
            typename std::remove_reference<T>::type&& move(T&& t) noexcept {
                return static_cast<typename std::remove_reference<T>::type&&>(t);
            }
        ```
        + `std::remove_reference` - type trait, убирающий из типа ссылки любого количества, и отдающий только тип `type&&`





+ `std::move()`
    + Входит в `#include <utility>`
    + "Используй `std::move()` только тогда, когда нужно явно переместить объект в другой скоуп"
        + Кто такой скоуп?
            + Скоуп здесь имеется ввиду как время жизни. Ресурсы объекта физически продолжают жизнь внутри другого объекта, не подпадая под время жизни своего старого владельца
    + Что произойдет, если попробовать вывести значение переменной `std::string name` после проведения  перемещения ее значения в другую переменную?
        + Unspecified
            + Мусор
            + Пустая строка
            + Та же самая строка **SSO**
                + 'SSO' - Short String Optimization
                    + В зависимости от реализации класса строки значение строки может храниться внутри полей объекта, а не как ссылка на память в куче (для этого размер строки должен быть довольно маленьким, 128байт). 
                    + `move` не будет занулять память внутри членов объекта, т.к. это займет время 
        + Поведение любого объекта зависит от реализации класса
    + `std::move()` не срабатывает, если "класть некуда" 
        + Пустой вызов функции не производит каких либо действий 
            + Внутри реализации `std::move` используется шаблонная магия для выполнения `static_cast()` над полученной ссылкой на переменную
                + Сам процесс перемещения реализуется уже в конструкторе класса, а не функцией `move()`. Эта функция лишь дает специальный тип, который "обозначили" стандартом для представления типа объектов для выполнения семантики перемещения
    + Явное и неявное перемещение
        + Куда-то потерялось
    + Получается, что `std::move()` и `std::forward()` - бесплатные операции




+ Мотивация к использованию `std::move()`
    + Прямое понятие перемещения из одной коллекции в другую 
        + Обычные способы перемещения объектов между коллекциями **требуют** содания копий и/или временных переменных. Даже если кажется, что копия не будет создана, она будет создана неявно
            + Может быть неактуально для объектов с отключенным конструктором копирования
            + Выполнение деаллокации памяти может быть столь же дорогим, что и аллокация
        + `std::move()` вместо этого делает прямую операцию перемещения, не создавая каких-либо копий
            ```c++
                strings2.emplace_back( std::move(strings1.back()) );
                strings1.pop_back()
            ```
            + При этом мувнутое значение лучше больше никогда не использовать - и попытаться его полностью зачистить (использовать `pop_back()` и зануление мувнутой переменной)
    + Помещение в коллекцию сложносоздаваемого объекта
        + Копировать такой объект просто-напросто дорого (если вообще возможно скопировать)
    + Насколько дорога эта функция?

    + Почему есть объекты, которые нельзя копировать?
        + Либо ошибка реализации класса
        + Либо специальные объекты, копирование которых создаст проблемы
            + `std::unique_ptr<type>`
            + `std::thread`
            + `std::mutex`    
    
+ Как работает `std::copy()`?
    ```c++
		string(const string& rhs) {
			m_size = rhs.m_size;
			m_data = new char[m_size];
			std::copy(rhs.m_data, rhs.m_data+m_size, m_data);
		}
    ```


+ Типы конструкторов
    + Конструктор создания
        + не нуждается в объяснении
    + Конструктор копирования
        + Позволяет создать полную копию объекта внутри переменной
    + Конструктор перемещения
        + Вызывает `swap` областей памяти полученных объектов (самого объекта и "правой стороны выражения")
            ```c++
                friend void swap(string& lhs, string& rhs) {
                    std::swap(lhs.m_data, rhs.m_data);
                    std::swap(lhs.m_size, rhs.m_size);
                }
            ```
        + Механика написания таких конструкторов перемещения требует создания собственного деструктора с `detele [] data`
        + Нужно очень точно отслеживать, что ситуация с указанием двух объектов на одну область памяти невозможна
    + Конструктор присваивания
        + Его поведение можно определять также с использованием конструктора перемещения (просто перемещение будет происходить над уже существующим объектом) - достаточно поставить `&&`
            + И эта штука заработает как перемещение `string t = std::move(a);`


+ Семантика перемещения
    + Синтаксически C++11 дает отдельные типы ссылок в зависимости от того, с какой стороны стоит объект (`&&` - rvalue_ref, `&` - lvalue_ref)
        + rvalue_ref нельзя присвоить какое-то значение (кроме ухищрений) - можно только читать это значение, писать в него нельзя
            + С++11 говорит, что можно (поэтому тип rvalue_ref ссылки используется для создания конструкторов перемещения)
            + `string(string&& rhs)`
        + Использование понятий rvalue_ref и lvalue_ref позволяет отделять типы передаваемых в функици значений 
            + Теперь можно отделить друг от друга левый и правый операнд в выражениях, и регулировать (с помощью перегрузок) поведение функции в зависимости от того, какая сторона выраженяи передана 
        + Все способы инициализации переменных чаще всего вызывают копирующие конструкторы
            + Если нужно выполнить перемещение - потребуется перестраивать тип объекта для перемещения под rvalue_ref (`string str_m{(string&&)(str1)}`)
                + Лучше вместо неудобного приведения использовать более правильный `std::move()`
                    + Вот откуда появляется `static_cast` - передаваемое в `move` значение должно быть приведено к rvalue_ref
                        + `typename std::remove_reference<T>::type&&` (здесь имеются ввиду эти самые `&&`)
    + Семантика перемещения и copy ellision (RVO и NRVO)
        + Copy ellision может оптимизировать поведение объекта при использовании `return string("Hello")` внутри функций даже без наличия конструктора перемещения
            + Компилятор пересобирает выражения, которые мы пишем, таким образом, чтобы по итогу не происходило копирований (какой-то такой пример ниже)
            ```c++
                void makeTracer(void* result, const char* name)
                {
                    new (Tracer) {(Tracer*)result, name}; //placement new
                }
            ```
            + Условия вызова copy elision
                + Возвращаемое значение соответствует типу результирующей переменной 
            + Заметка для неиспользования `std::move()`
                + Не нужно использовать rvalue_ref для результата работы функции - он и так по умолчанию станет rvalue_ref
            + NRVO (когда результат функции объявляется как переменная в функции) - отдельный механизм, вроде бы фактически ничем не отличающися от RVO (но компиляторы его выделяют)
            + RVO + NRVO делают невозможным подсчет количества копирований - их может быть как много, так и не быть совсем, это будет зависеть от решения компилятора, делать ли RVO, или нет.
                + Эти оптимизации можно отключать флагами



        + Но если по итогу этот конструктор не получится вызвать - будет вызван конструктор перещмения
            + Если его нет - останется обычное копирование
    + Семантика и константность
        + Разрешено приведение `const string&& -> const striing&`. Соответственно происходят и остальные изменения поведения 
    + Семантика перемещений не дает преимуществ пока нет объектов, которые не хочется копировать (ресурсы вроде сокетов, хендлеров, крупных кусков памяти)



+ Дополнительные особенности использования семантики перемещения и типов значений
    + Правило склеивания ссылок
        + Амерсандов для представления ссылок не может быть больше 2 - от большего числа будет браться остаток от деления
        + Примеры:
            + Применение rvalue_ref на rvalue_ref -> rvalue_ref
                + T&& + int&& -> int&&
            + Применение lvalue_ref на rvalue_ref -> lvalue_ref
                + T& + int&& -> int&
            + Явный пример
                `int tempateFunction(t&& val)`
                `teplateFunction(std::move(a))`
                `templateFunction(a)`
    + Именнованная переменная - всегда lvalue_ref. Вне зависимости от типа
    + `std::forward<T>` позволяет передать rvalue_ref и lvalue_ref как они есть, без автоматического перепредставления rvalue->lvalue
        + Она вызовет `std::move()` только в том случае, если переданная в нее переменная сама по себе имеет тип rvalue, чтобы по итогу была вызвана функция с правильным поведением 
        + Красивое синтаксическое чудо для использования:
        ```c++
        class String{
            template<typename T>
            String(T&& param) : m_value{std::forward(param)};
        private:
            std::string m_value; //const char*,std::string&, std::string&& ....
        }

        ```










+ variadic templates (шаблоны с переменным числом аргументов)
    + Передача бесконечного числа аргументов
        + C дает передачу бесконечного числа аргументов с помощью `<cstdarg>`
            + Добавляется элипсис (`...` может быть поставлено как последний параметр в объявление функции)
            + Добавляется структура `va_list` (представляет собой список всех переданных значений в аргументы функции)
                + Добавляются функции обеспечения взаимодействия с этим `va_list`
                    + `va_start(va_list*, int size)`
                    + `va_arg(va_list*, type_cast)`
                    + `va_end(va_list*)` (завершение работы со структурой для ее очистки) 
        + С++ дает использование `typename...` для обозначения variadic templates
            + В С++11 на эту штуку можно только натравить sizeof() чтобы знать размер, а затем сделать раскрытие
                + На этапе подстановки шаблонов использование `values...` приведет к раскрытию шаблона со всеми переданными типами (`int value1, char value2...`)
                    + Шаблон раскрывается в любом месте с упоминанием этого `values` и многоточия, генерируя неподходящие технически для языка шаблоны 
                        + Пример: `(1 + values)...` -> `(1 + value1), (1 + value2)...`
                            Конструкция странная - запятые и отсутствие контроля типа valueN
                + Варианты издевательства над этим ужасом в C++11
                    + Рекурсия
                        + Создается еще один шаблон, который принимает в себя первым параметром обыный аргумент, а вторым - такой же variadic template
                        + В самом конце такой функции нужно вызвать эту же функцию с раскрытием variadic teplate-а
                        + Особенность в том, что функция "без параметров" также должна существовать как конечный случай рекурсии
            + Некоторыми дополнительными стредствами новых версий C++ можно заставить эти шаблоны быть однотипными, но с бесконечным количеством аргументов. Тогда взаимодействие с этими вариадик шаблонами становится интереснее






+ Дополнение лямбд
    + Передача по значению и по ссылке
        + Использование ссылки (&) позволяет заставить лямбды получить значения по ссылке (одно или все сразу)
    + Захват значения (того, что будет помещено в квадратные скобки) происходит в моменте создания лямбды (все значения пойдут в члены создаваемого класса)
    + Страшная запись `auto temp = +[](){}`
        + Компиляторы создают лямбды без захвата на основе обычных функций, получая в итоге для `temp` указатель на функцию
            + Оказывается, к указатяелям на функцию можно применять бесполезный унарный плюс
        + Как только появятся аргументы захвата - программа не будет скомпилирована, т.к. будет создаваться полноценынй объект лямбда-функции



+ Просто дополнительные примочки
    + explicit
        + Запрети компилятору автоматические преобразования и конструирования объектов налету!
            + Компилятор может автоматически сконструировать объект на основе передаваемых простых значений, таким образом оказываясь способным создавать проблемки
            + Внутренние ускорения от использования автоматических преобразованйи все равно будут выполнены
                + Плюс лишь в том, что теперь преобразования и аргументы ставноятся явными 