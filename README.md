# CICD для CPP

+ Задачи
    + ~~Как использовать ClangFormat в VSCode?~~
        + По идее, даже clang-format для системы не нужен - `Ctrl+Shift+I`
    + ~~Использование GTest вместо libboost~~





+ Ошибка верхнего уровня
    + Собранный CPack пакет содержит gmock и gtest
        + Явное решение - использование `git submodule`
        + Дополнительные проблемы с целями
            + Команда `install()` позволяет определить процесс установки бинарных и небинарных файлов в систему конечного пользователя. 
            + У меня каким-то образом тестовый бинарник также добавился в систему, что привело к проблемам (опять)
                + Понадобилось просто исключить тестовую цель как цель для установок
    + ~~**Желание найти решение внутри Cmake**~~
    + Что случилось? 
        + Оказывается, если использовать библиотеки вроде gtest для проведения тестирований работы бинарника тестов, то эти библиотеки начинают автоматически включаться и в окончательный пакет сборки модуля CPack
            + У самого CMake нет возможности сказать CPack использовать только отдельные бинарники и либы для сборки пакета - он соберет все цели сборки в один пакет все равно
        + Отличительный способ - использование `git submodule`
            + Дополнительный репозиторий для сборки подключается к репозиторию со сборкой CMake
            + Компоненты gtest начинают восприниматься как отдельные части, которые можно ИСКЛЮЧИТЬ ИЗ СБОРКИ
                + Делается внутри `add_subdirectory(... EXCLUDE_FROM_ALL)` - подпроект удаляется как зависимость для всех целей
            + Проблема в том, что сборка самого проекта в таком случае становится архисложной
        + Что значит "интерфейсная библиотека?"
		    + Библиотека, которая создает интерфейс для взаимодействия самого бинарника и дополнительных бинарников GTest
			    + Бинарники GTest компилируются вместе с добавлением `add_subdirectory`
			    + Функционал бинарников GTest нужно передать основному тестовому бинарнику - и делается это с помощью интерфейсной библиотеки
				    + Она передает только заголовочные файлы, позволяя использовать GTest как динамическую библиотеку, собранную в другом месте



+ CMake (googletest)
```bash
git submodule add <href>
```

```cmake
add_subdirectory(external/googletest EXCLUDE_FROM_ALL)

# Создаем интерфейсную библиотеку для gtest
add_library(GTest::GTest INTERFACE IMPORTED)
target_include_directories(GTest::GTest INTERFACE ${GTEST_INCLUDE_DIRS})
target_link_directories(GTest::GTest INTERFACE ${GTEST_LIBRARY_DIR})
target_link_libraries(GTest::GTest INTERFACE gtest)

# Создаем интерфейсную библиотеку для gtest_main
add_library(GTest::Main INTERFACE IMPORTED)
target_include_directories(GTest::Main INTERFACE ${GTEST_INCLUDE_DIRS})
target_link_directories(GTest::Main INTERFACE ${GTEST_LIBRARY_DIR})
target_link_libraries(GTest::Main INTERFACE gtest_main)


target_link_libraries(test_version PRIVATE GTest::Main helloworld)

# Включение тестирования
enable_testing()
add_test(test_version test_version)

include(GoogleTest)
gtest_discover_tests(test_version)
```




```Cmake (уже не рабочий)
include(FetchContent)
FetchContent_Declare(
  googletest
  GIT_REPOSITORY https://github.com/google/googletest.git
  GIT_TAG main  
)



target_link_libraries(
  test_version
  GTest::gtest_main  ./ciadpi --disorder 4 --auto=torst --tlsrec 4+s
  helloworld
)


enable_testing()

add_test(test_version test_version)

include(GoogleTest)
gtest_discover_tests(test_version)
```


    




+ Окружение
    + кодировки
    + форматирования (чаще всего используется CLangFormat)
        + Нужно посмотреть, как сделать оформление кода в VSCode на оснвое CLangFormat
    + Документация 
        + Писать документацию к классам и функциям (в частности инструмент doxygen)
    + Code style (struct VS class, exceptions)
        + Здесь выделено отдельно - форматирование и кодстайл. Кодстайл относится к используемым принципам языка
        + Как пример
            + Не надо использовать приватное наследование, вместо него использовать композицию классов
    + Сборка проектов
        + Печаль с переносом кода и процессов сборки туда-сюда
        + Для платформонезависимости - использование *CMake*
            + src содержит "вроде бы" неплохой дефолтный компонентер

+ Так, ну, проблемы с наличием у меня Boost - совсем другое дело, опустим - просто произведена установка Boost в систему



+ release.yml
    + Во-первых, благодаря GPT переписал использование ubuntu->смешанное использование ubuntu+fedora (ubuntu будет дальше использоваться для GithubActions, но внутренний кусок CMake для запуска проекта у меня должен собирать пакет для RPM)
        + Использует `boost-devel` на моей машине (ставлю пока сам) - на ubuntu остается libboost-test
        + Для сборки проекта дополнительно указывается ключ `-DCMAKE_GENERATOR`
            + Основная опция - RPM (для моей работы)
            + В остальном будет собирать для deb
            + Опция убрана из release.yml
        + Этот ключ проверяется в CMakeLists
        + ? Почему libboost?
            + Показывают, как ставить зависимости, другие фреймворки тестирования удобнее ставить другими средствами
                + ?? Как поставить GTest?

    + Во-вторых, объяснение самого файла
        + Для тригерра пуша в ветки master и feature выполняется основная задача сборки и тестирования (объединенная задача со всеми компонентами)
        + Основные задачи по тестированию и формированию пакета делает сама CMake
            + test - запускает тесты (`boost-test`)
            + package - собирает пакет нужным образом для дистрибутива (у меня пока стоит RPM в Fedora-cmake, но если что я могу объединить их в одно целое)

    + В третьих - токены
        + Для запуска контейнеров также нужны токены Github, у меня действующий токен - `repos`, его имя и нужно указывать в `GITHUB_TOKEN` в настройках репозитория
            + Вообще здесь появляется определенная сложность использования этих самых токенов
            + Токены вносятся в Secrets внутри настроек самого репозитория
        + По итогу проблема была в том, что создаваемый динамический токен не имел прав доступа на запись релиза. Решается в Settings->Actions->General->Workflow Permissions


+ CMakeLists
    + `CMAKE_BINARY_DIR` - директория, откуда был запущен CMake. Если ее подключить к проекту, то CMake сможет тяпать собираемые в директории `build` библиотеки и подключать их к проекту
    + С помощью CMake можно выставлять `#define`
        + `set_target_properties(target PROPERTIES COMPILE_DEFINITIONS BOOST_TEST_DYN_LINK ...)`
            + эквивалентно `#define BOOST_TEST_DYN_LINK`
                + Само включение нужно чтобы позволить `boost_test` искать динамические либки
    + Сборка пакетов
        + Для сборки пакетов в CMake используется `CPack`. В последних строчках он как раз подключается, и использует выше поставленные переменные для выполнения своей работы над `helloworld-cli`
        + Далее можно использоввать `--target package` при сборке с помощью CMake (как раз происходит в release.yml)
    + Тестирование
        + `enable_testing()`
        + Некоторый бинарник регистрируется в качестве цели сборки для тестирования. Затем можно использовать `--target test` для проведения тестирования средствами CMake + Boost
    + Версионирование
        + Кроме применения текста из CMakeLists, также значения переменных можно передавать с помощью комнадной строки при запуске. 
        + Дефолтно этот бинарник использует `PATCH_VERSION=1`, но в `release.yml` уже передается другая версия - которая получается из синтаксиса акшенов самого Github 
+ Использование `.in` файла
    + Позволяет CMake дополнительно взаимодействовать с C++
        + Делается с помощью `configure_file`
    + Вставляет `#define` с использованием переменных, созданных самим CMake
        + `#cmakedefine`
    + incomplete - фактически расширение может быть любым, CMake на эти расшрения без разницы